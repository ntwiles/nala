use std::str::FromStr;

use crate::ast;

grammar;

match {
    "{", "}", "(", ")", "[", "]", ";", ":", ".", ",",
    "const", "mut", "if", "for", "in", "wiles", "func", "break", "struct",
    "=", "==", ">", "<", "+", "-", "*", "/",
    "Array", "Bool", "Func", "Number",  "Object", "String",

    r"[a-zA-Z]+",           // symbols
    r"-?[0-9]+(\.[0-9]+)?", // number literals
    r"'[^']*'",             // string literals

    // Skip whitespace and comments
    r"\s*" => { },
    r"//[^\n\r]*[\n\r]*" => { }, // `// comment`
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { }, // `/* comment */`
}

pub Program: ast::Program = {
    <Block> => ast::Program::Block(<>),
    <Stmts> => ast::Program::Stmts(<>)
}

Block: ast::Block = {
    "{" <Stmts> "}" => ast::Block::NalaBlock(<>)
}

pub Stmts: ast::Stmts = {
    <ss:Stmts> <s:Stmt> => ast::Stmts::Stmts(Box::new(ss), s),
    Stmt => ast::Stmts::Stmt(<>),
};

Stmt: ast::Stmt = {
    "const" <s:Symbol> "=" <e:Expr> ";" => ast::Stmt::Declare(s, e, false),
    "mut" <s:Symbol> "=" <e:Expr> ";" => ast::Stmt::Declare(s, e, true),
    "if" "(" <e:Expr> ")" <b:Block> => ast::Stmt::If(e, Box::new(b)),
    "for" <s:Symbol> "in" <e:Expr> <b:Block> => ast::Stmt::For(s,e, Box::new(b)),
    "wiles" "(" <e:Expr> ")" <b:Block> => ast::Stmt::Wiles(e, Box::new(b)),
    "func" <s:Symbol> "(" <p:Params> ")" <b:Block> => ast::Stmt::Func(ast::funcs::Func{ ident: s, params: p, block: Box::new(b)}),
    "break" "(" <Expr> ")" ";" => ast::Stmt::Break(<>),
    "struct" <s:Symbol> "{" <ff:StructFields> "}" => ast::Stmt::Struct(s, ff),
    <s:PlaceExpression> "=" <e:Expr> ";" => ast::Stmt::Assign(s, e),
    <e:Expr> ";" => ast::Stmt::Expr(e),
};

PlaceExpression: ast::PlaceExpression = {
    <p:PlaceExpression> "[" <e:Expr> "]" => ast::PlaceExpression::Index(Box::new(p), Box::new(e)),
    <MemberAccess> => ast::PlaceExpression::MemberAccess(Box::new(<>)),
    <Symbol> => ast::PlaceExpression::Symbol(<>),
};

VariantsDeclare = Comma<VariantDeclare>;

VariantDeclare: ast::VariantDeclare = {
    <Symbol> => ast::VariantDeclare::Empty(<>),
    <s:Symbol> "(" <t:TypeVariant> ")" => ast::VariantDeclare::Data(s, t)
};

Expr: ast::Expr = {
    <l:Expr> "==" <r:Addend> => ast::Expr::Eq(Box::new(l), r),
    <l:Expr> ">" <r:Addend> => ast::Expr::Gt(Box::new(l), r),
    <l:Expr> "<" <r:Addend> => ast::Expr::Lt(Box::new(l), r),
    Addend => ast::Expr::Addend(<>),
    Array => ast::Expr::Array(<>),
    Object => ast::Expr::Object(<>),
};

Object: ast::objects::Object = {
    "{" <KeyValuePairs> "}" => ast::objects::Object { entries: <>}
}

KeyValuePairs = Comma<KeyValuePair>;

KeyValuePair: ast::objects::KeyValuePair = {
    <s:Symbol> ":" <e:Expr> => ast::objects::KeyValuePair{ key: s, value: Box::new(e)}
}

Elems = Comma<Expr>;

Array: ast::arrays::Array = {
    "[" <Elems> "]" => ast::arrays::Array { elems: <> },
};

Params = Comma<Param>;

Param: ast::funcs::Param = {
    <s:Symbol> ":" <t:TypeVariant> => ast::funcs::Param { ident: s, param_type: t }
}

StructFields = Comma<StructField>;

StructField: ast::types::StructField = {
    <s:Symbol> ":" <t:Type> => ast::types::StructField { ident: s, field_type: ast::types::type_variant::TypeVariant::Type(t) },
}

TypeVariants = Comma<TypeVariant>;

TypeVariant: ast::types::type_variant::TypeVariant = {
    <t:Type> "<" <tt:TypeVariants> ">" => ast::types::type_variant::TypeVariant::Nested(t, tt),
    <Type> => ast::types::type_variant::TypeVariant::Type(<>),
}

Type: ast::types::nala_type::NalaType = {
    <PrimitiveType> => ast::types::nala_type::NalaType::PrimitiveType(<>),
    <Symbol> => ast::types::nala_type::NalaType::UserDefined(<>),
}

PrimitiveType: ast::types::primitive_type::PrimitiveType = {
    "Array" => ast::types::primitive_type::PrimitiveType::Array,
    "Bool" => ast::types::primitive_type::PrimitiveType::Bool,
    "Func" => ast::types::primitive_type::PrimitiveType::Func,
    "Number" => ast::types::primitive_type::PrimitiveType::Number,
    "Object" => ast::types::primitive_type::PrimitiveType::Object,
    "String" => ast::types::primitive_type::PrimitiveType::String,
}

pub Addend: ast::math::Addend = {
    <l:Addend> "+" <r:Factor> => ast::math::Addend::Add(Box::new(l), r),
    <l:Addend> "-" <r:Factor> => ast::math::Addend::Sub(Box::new(l), r),
    Factor =>  ast::math::Addend::Factor(<>)
};

pub Factor: ast::math::Factor = {
    <l:Factor> "*" <t:Term> => ast::math::Factor::Mult(Box::new(l), t),
    <l:Factor> "/" <t:Term> => ast::math::Factor::Div(Box::new(l), t), 
    Invocation => ast::math::Factor::Invocation(<>),
};

Invocation: ast::funcs::Invocation = {
    <p:PlaceExpression> "(" <e:Elems> ")" => ast::funcs::Invocation::Invocation(p, e),
    <PlaceExpression> => ast::funcs::Invocation::PlaceExpression(<>),
    <Value> => ast::funcs::Invocation::Value(<>),
};

MemberAccess: ast::objects::MemberAccess = {
    <p:MemberAccess> "." <c:Symbol> => ast::objects::MemberAccess::MemberAccesses(Box::new(p), c),
    <p:Symbol> "." <c:Symbol> => ast::objects::MemberAccess::MemberAccess(p, c),
}

Term: ast::terms::Term = {
    Symbol => ast::terms::Term::Identifier(<>),
    Value => ast::terms::Term::Value(<>),
};

Value: ast::terms::Value = {
    Num => ast::terms::Value::Num(<>),
    Str => ast::terms::Value::String(<>),
}

Symbol: String = {
    r"[a-zA-Z]+" => String::from_str(<>).unwrap()
};

Num: f32 = {
    r"-?[0-9]+(\.[0-9]+)?" => f32::from_str(<>).unwrap(),
};

Str: String = {
    r"'[^']*'" => String::from_str(&<>[1..<>.len() - 1]).unwrap(),
};

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};